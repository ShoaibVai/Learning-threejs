{
  "id": "state-management",
  "title": "Game State & Scene Management",
  "slug": "state-management",
  "overview": "Organize game code with state machines and scene systems for menu, gameplay, pause, and game over screens.",
  "objectives": ["Implement state machine pattern", "Create scene system (menu, game, pause)", "Handle scene transitions", "Manage game data between scenes"],
  "prerequisites": ["Game loop", "Object-oriented programming"],
  "durationMinutes": 60,
  "order": 1,
  "sections": [{"type": "reading", "title": "State Management", "content": "# Game States\n\n## State Machine Pattern\n\n```javascript\nclass GameStateMachine {\n    constructor() {\n        this.states = {};\n        this.currentState = null;\n    }\n    \n    add(name, state) {\n        this.states[name] = state;\n    }\n    \n    switch(name) {\n        if (this.currentState) {\n            this.currentState.exit();\n        }\n        this.currentState = this.states[name];\n        this.currentState.enter();\n    }\n    \n    update(dt) {\n        if (this.currentState) {\n            this.currentState.update(dt);\n        }\n    }\n    \n    render(ctx) {\n        if (this.currentState) {\n            this.currentState.render(ctx);\n        }\n    }\n}\n\nclass MenuState {\n    enter() { /* setup */ }\n    exit() { /* cleanup */ }\n    update(dt) { /* logic */ }\n    render(ctx) { /* draw */ }\n}\n```\n\n## Common States\n\n- Loading\n- Menu\n- Playing\n- Paused\n- GameOver\n- Settings"}],
  "resources": [{"title": "Game Programming Patterns: State", "url": "https://gameprogrammingpatterns.com/state.html", "type": "article"}, {"title": "Finite State Machines", "url": "https://www.youtube.com/watch?v=Qa6csfkK7_I", "type": "video"}],
  "miniProject": {"title": "Multi-Scene Game with Menus", "description": "Add complete menu system with state transitions", "estimatedTime": 70, "steps": ["Create GameStateMachine class", "Implement MenuState with start button", "Create PlayingState with your game", "Add PauseState (ESC to toggle)", "Create GameOverState with restart", "Implement state transitions", "Persist high score between games"], "deliverables": ["Working state machine", "All scenes functional", "Smooth transitions"], "rubric": ["State machine works (3 pts)", "All scenes implemented (3 pts)", "Transitions smooth (2 pts)", "Data persistence (2 pts)"], "starterPath": "/practice/game-starters/canvas-vite-ts"},
  "quiz": {"passingScore": 70, "questions": [{"id": "q1", "type": "single", "question": "What is a state machine?", "options": ["A type of computer", "System with defined states and transitions", "Graphics rendering system", "Network protocol"], "correctAnswer": "System with defined states and transitions", "explanation": "State machines manage distinct states (menu, game, pause) and transitions between them.", "points": 15}, {"id": "q2", "type": "multiple", "question": "State lifecycle methods?", "options": ["enter()", "update()", "render()", "delete()"], "correctAnswer": ["enter()", "update()", "render()"], "explanation": "States typically have enter (setup), update (logic), render (draw), and exit (cleanup).", "points": 20}, {"id": "q3", "type": "single", "question": "When should state cleanup happen?", "options": ["In enter()", "In update()", "In exit()", "In constructor"], "correctAnswer": "In exit()", "explanation": "exit() is called when leaving a state, perfect for cleanup.", "points": 10}, {"id": "q4", "type": "single", "question": "How to pause game properly?", "options": ["Stop game loop", "Switch to pause state", "Clear canvas", "Disable inputs"], "correctAnswer": "Switch to pause state", "explanation": "Pause state stops updates but can still render and handle unpause input.", "points": 15}, {"id": "q5", "type": "short-answer", "question": "Why use state pattern instead of if/else everywhere?", "correctAnswer": "State pattern encapsulates state-specific behavior, makes code more maintainable, easier to add new states, and prevents spaghetti code with complex conditionals", "explanation": "State pattern provides clean separation and makes complex behavior manageable.", "points": 40}]},
  "environment": {"setupSteps": ["Build on previous game project", "Create separate files for each state", "Consider TypeScript for better structure"], "commands": ["# Debug current state\nconsole.log('Current state:', stateMachine.currentState.constructor.name);"], "troubleshooting": [{"issue": "State not switching", "solution": "Check: 1) State registered with add()? 2) Correct state name in switch()? 3) enter() being called?"}, {"issue": "Previous state still updating", "solution": "Ensure exit() is called and cleans up timers/listeners. Only update currentState."}]}
}
