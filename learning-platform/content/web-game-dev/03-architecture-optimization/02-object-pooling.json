{
  "id": "object-pooling",
  "title": "Performance Optimization & Object Pooling",
  "slug": "object-pooling",
  "overview": "Optimize game performance with object pooling, reduce garbage collection, and implement efficient rendering techniques.",
  "objectives": ["Implement object pooling pattern", "Reduce garbage collection", "Optimize rendering", "Profile and measure performance"],
  "prerequisites": ["Game loop", "JavaScript objects and arrays"],
  "durationMinutes": 65,
  "order": 2,
  "sections": [{"type": "reading", "title": "Performance Optimization", "content": "# Object Pooling\n\n## The Problem\n\nCreating/destroying objects causes garbage collection:\n\n```javascript\n// BAD: Creates new bullet every frame\nfunction shoot() {\n    const bullet = new Bullet(x, y); // GC stress!\n    bullets.push(bullet);\n}\n```\n\n## The Solution: Object Pool\n\n```javascript\nclass ObjectPool {\n    constructor(factory, size = 100) {\n        this.pool = [];\n        this.factory = factory;\n        \n        for (let i = 0; i < size; i++) {\n            this.pool.push(factory());\n        }\n    }\n    \n    get() {\n        return this.pool.pop() || this.factory();\n    }\n    \n    release(obj) {\n        this.pool.push(obj);\n    }\n}\n\n// Usage\nconst bulletPool = new ObjectPool(() => new Bullet());\n\nfunction shoot() {\n    const bullet = bulletPool.get();\n    bullet.init(x, y); // Reset state\n}\n\nfunction removeBullet(bullet) {\n    bulletPool.release(bullet); // Reuse!\n}\n```\n\n## Other Optimizations\n\n1. **Batch rendering**: Draw similar objects together\n2. **Dirty rectangles**: Only redraw changed areas\n3. **Culling**: Don't render offscreen objects\n4. **Reduce Math operations**: Cache calculations"}],
  "resources": [{"title": "Object Pool Pattern", "url": "https://gameprogrammingpatterns.com/object-pool.html", "type": "article"}, {"title": "Chrome DevTools Performance", "url": "https://developer.chrome.com/docs/devtools/performance/", "type": "documentation"}],
  "miniProject": {"title": "Optimized Particle System", "description": "Create efficient particle system with pooling handling 1000+ particles", "estimatedTime": 70, "steps": ["Create Particle class", "Implement ObjectPool", "Spawn 1000 particles on click", "Profile with/without pooling", "Add FPS counter", "Implement culling (don't render offscreen)", "Add sprite batching if possible"], "deliverables": ["Object pool working", "Smooth 60 FPS with 1000+ particles", "Performance comparison"], "rubric": ["Object pool implemented (3 pts)", "Maintains 60 FPS (3 pts)", "Culling working (2 pts)", "Performance profiled (2 pts)"], "starterPath": "/practice/game-starters/canvas-vite-ts"},
  "quiz": {"passingScore": 70, "questions": [{"id": "q1", "type": "single", "question": "What is object pooling?", "options": ["Combining objects into groups", "Reusing objects instead of creating/destroying", "Sorting objects by type", "Saving objects to database"], "correctAnswer": "Reusing objects instead of creating/destroying", "explanation": "Object pooling pre-allocates objects and reuses them, avoiding GC overhead.", "points": 15}, {"id": "q2", "type": "single", "question": "Main benefit of object pooling?", "options": ["Easier code", "Reduces garbage collection", "Better graphics", "Smaller file size"], "correctAnswer": "Reduces garbage collection", "explanation": "Pooling prevents frequent allocation/deallocation, reducing GC pauses.", "points": 15}, {"id": "q3", "type": "multiple", "question": "Performance optimization techniques?", "options": ["Object pooling", "Culling offscreen objects", "Drawing everything every frame", "Batching similar draws"], "correctAnswer": ["Object pooling", "Culling offscreen objects", "Batching similar draws"], "explanation": "Pool objects, cull invisible ones, batch similar rendering. Don't needlessly redraw.", "points": 20}, {"id": "q4", "type": "single", "question": "How to profile JavaScript performance?", "options": ["console.log()", "Chrome DevTools Performance tab", "alert()", "Debugger"], "correctAnswer": "Chrome DevTools Performance tab", "explanation": "Performance tab shows CPU usage, rendering time, and bottlenecks.", "points": 10}, {"id": "q5", "type": "short-answer", "question": "When should you use object pooling?", "correctAnswer": "When frequently creating and destroying many short-lived objects like bullets, particles, or enemies, to avoid garbage collection overhead", "explanation": "Pool objects that have high creation/destruction frequency.", "points": 40}]},
  "environment": {"setupSteps": ["Use previous canvas project", "Open Chrome DevTools > Performance", "Record performance profile"], "commands": ["# FPS counter\nlet fps = 0, frameCount = 0, lastTime = performance.now();\nfunction updateFPS(currentTime) {\n    frameCount++;\n    if (currentTime >= lastTime + 1000) {\n        fps = frameCount;\n        frameCount = 0;\n        lastTime = currentTime;\n    }\n}"], "troubleshooting": [{"issue": "Still getting low FPS", "solution": "Profile to find bottleneck. Check: 1) Drawing too much? 2) Complex calculations in loop? 3) Too many objects?"}, {"issue": "Pool running out of objects", "solution": "Increase pool size or make it dynamically grow. Ensure objects are being released back."}]}
}
