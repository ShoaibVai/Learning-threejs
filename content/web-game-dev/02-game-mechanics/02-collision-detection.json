{
  "id": "collision-detection",
  "title": "Collision Detection Fundamentals",
  "slug": "collision-detection",
  "overview": "Implement collision detection algorithms for rectangles, circles, and points to create interactive game physics.",
  "objectives": ["Understand bounding boxes and collision shapes", "Implement AABB collision detection", "Detect circle collisions", "Optimize with spatial partitioning"],
  "prerequisites": ["Canvas basics", "Basic geometry and algebra"],
  "durationMinutes": 65,
  "order": 2,
  "sections": [{"type": "reading", "title": "Collision Detection", "content": "# Collision Detection\n\n## AABB (Axis-Aligned Bounding Box)\n\nSimplest and fastest collision detection:\n\n```javascript\nfunction checkAABB(rect1, rect2) {\n    return rect1.x < rect2.x + rect2.width &&\n           rect1.x + rect1.width > rect2.x &&\n           rect1.y < rect2.y + rect2.height &&\n           rect1.y + rect1.height > rect2.y;\n}\n```\n\n## Circle Collision\n\n```javascript\nfunction checkCircles(c1, c2) {\n    const dx = c1.x - c2.x;\n    const dy = c1.y - c2.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < c1.radius + c2.radius;\n}\n```\n\n## Point in Rectangle\n\n```javascript\nfunction pointInRect(px, py, rect) {\n    return px >= rect.x && px <= rect.x + rect.width &&\n           py >= rect.y && py <= rect.y + rect.height;\n}\n```\n\n## Optimization: Spatial Partitioning\n\nDon't check all pairs (O(n²))! Use:\n- **Quadtree**: Divide space into regions\n- **Grid**: Fixed-size cells\n- **Broad phase → Narrow phase**"}],
  "resources": [{"title": "Collision Detection MDN", "url": "https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection", "type": "article"}, {"title": "Quadtree Implementation", "url": "https://github.com/timohausmann/quadtree-js", "type": "tool"}],
  "miniProject": {"title": "Pong Clone with Collision", "description": "Build classic Pong with accurate collision detection", "estimatedTime": 75, "steps": ["Create paddles (AABB)", "Create ball (circle)", "Implement ball-paddle collision", "Implement ball-wall collision", "Add bounce physics (reflect velocity)", "Add score tracking", "Optional: AI opponent"], "deliverables": ["Working Pong game", "Accurate collision", "Score system"], "rubric": ["Collision detection (4 pts)", "Bounce physics (3 pts)", "Game playable (2 pts)", "Score tracking (1 pt)"], "starterPath": "/practice/game-starters/canvas-vite-ts"},
  "quiz": {"passingScore": 70, "questions": [{"id": "q1", "type": "single", "question": "What is AABB?", "options": ["Advanced Animation Bounding Box", "Axis-Aligned Bounding Box", "Automatic Asset Batch Builder", "Animated Asset Background"], "correctAnswer": "Axis-Aligned Bounding Box", "explanation": "AABB is a rectangle aligned with axes, enabling fast collision checks.", "points": 10}, {"id": "q2", "type": "single", "question": "Circle collision formula?", "options": ["distance < r1 + r2", "distance > r1 + r2", "distance == r1 + r2", "distance < r1 * r2"], "correctAnswer": "distance < r1 + r2", "explanation": "Circles collide when distance between centers is less than sum of radii.", "points": 15}, {"id": "q3", "type": "single", "question": "Why use spatial partitioning?", "options": ["Better graphics", "Faster collision detection", "Easier coding", "More accurate"], "correctAnswer": "Faster collision detection", "explanation": "Spatial partitioning reduces collision checks from O(n²) to O(n log n) or better.", "points": 15}, {"id": "q4", "type": "multiple", "question": "Collision optimization techniques?", "options": ["Quadtree", "Grid partitioning", "Check all pairs", "Broad/narrow phase"], "correctAnswer": ["Quadtree", "Grid partitioning", "Broad/narrow phase"], "explanation": "Spatial structures and multi-phase detection optimize collision checks.", "points": 20}, {"id": "q5", "type": "short-answer", "question": "Explain broad phase vs narrow phase collision", "correctAnswer": "Broad phase quickly eliminates impossible collisions using simple checks (like bounding boxes), then narrow phase does precise collision detection only on potential pairs", "explanation": "Two-phase detection optimizes by doing cheap checks first, expensive checks only when needed.", "points": 40}]},
  "environment": {"setupSteps": ["Use canvas starter", "Consider using TypeScript for type safety with collision shapes", "Draw collision bounds for debugging"], "commands": ["# Visualize collision bounds\nctx.strokeStyle = 'red';\nctx.strokeRect(entity.x, entity.y, entity.width, entity.height);"], "troubleshooting": [{"issue": "Collisions not detecting", "solution": "Check: 1) Coordinates correct? 2) Using correct formula? 3) Drawing collision bounds to debug visually?"}, {"issue": "Ball passes through paddle at high speed", "solution": "Tunneling problem. Use swept collision detection or limit max velocity."}]}
}
