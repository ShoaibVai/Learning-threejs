{
  "id": "game-architecture",
  "title": "Clean Game Architecture & ECS Intro",
  "slug": "game-architecture",
  "overview": "Design maintainable game code with Entity-Component-System (ECS) pattern, separation of concerns, and modular architecture.",
  "objectives": ["Understand Entity-Component-System pattern", "Separate rendering from logic", "Create modular, testable code", "Build reusable game systems"],
  "prerequisites": ["Object-oriented programming", "Previous game dev lessons"],
  "durationMinutes": 70,
  "order": 3,
  "sections": [{"type": "reading", "title": "Game Architecture Patterns", "content": "# Entity-Component-System (ECS)\n\n## Traditional OOP Problem\n\n```javascript\nclass Player extends GameObject {\n    // Has everything: rendering, physics, input\n    // Hard to reuse, tightly coupled\n}\n```\n\n## ECS Solution\n\n**Entity**: Just an ID\n**Component**: Pure data\n**System**: Logic operating on components\n\n```javascript\n// Components (data only)\nclass Position { x = 0; y = 0; }\nclass Velocity { vx = 0; vy = 0; }\nclass Sprite { image = null; }\n\n// Systems (logic only)\nclass PhysicsSystem {\n    update(entities, dt) {\n        for (let entity of entities) {\n            if (entity.has(Position, Velocity)) {\n                const pos = entity.get(Position);\n                const vel = entity.get(Velocity);\n                pos.x += vel.vx * dt;\n                pos.y += vel.vy * dt;\n            }\n        }\n    }\n}\n\nclass RenderSystem {\n    render(entities, ctx) {\n        for (let entity of entities) {\n            if (entity.has(Position, Sprite)) {\n                const pos = entity.get(Position);\n                const sprite = entity.get(Sprite);\n                ctx.drawImage(sprite.image, pos.x, pos.y);\n            }\n        }\n    }\n}\n```\n\n## Benefits\n\n- **Composition over inheritance**\n- **Easy to add/remove features**\n- **Systems are reusable**\n- **Better performance** (data-oriented)"}],
  "resources": [{"title": "Entity Component System FAQ", "url": "https://github.com/SanderMertens/ecs-faq", "type": "article"}, {"title": "Game Programming Patterns", "url": "https://gameprogrammingpatterns.com/", "type": "article"}],
  "miniProject": {"title": "Refactor Game with ECS", "description": "Rebuild a previous game project using ECS architecture", "estimatedTime": 90, "steps": ["Create Entity class (component container)", "Define components: Position, Velocity, Sprite, Health", "Create PhysicsSystem", "Create RenderSystem", "Create InputSystem", "Refactor player to use components", "Add enemies using same components", "Test modularity by adding new entity types"], "deliverables": ["Working ECS implementation", "Multiple entity types", "Clean, modular code"], "rubric": ["ECS basics working (4 pts)", "Multiple systems (3 pts)", "Code is modular (2 pts)", "Multiple entity types (1 pt)"], "starterPath": "/practice/game-starters/canvas-vite-ts"},
  "quiz": {"passingScore": 70, "questions": [{"id": "q1", "type": "single", "question": "What is an Entity in ECS?", "options": ["A game object with methods", "Just an ID/container for components", "A rendering system", "A data structure"], "correctAnswer": "Just an ID/container for components", "explanation": "Entities are lightweight containers; behavior comes from components and systems.", "points": 15}, {"id": "q2", "type": "single", "question": "What do Components contain?", "options": ["Logic and methods", "Only data", "Rendering code", "User input handling"], "correctAnswer": "Only data", "explanation": "Components are pure data. Systems contain the logic.", "points": 15}, {"id": "q3", "type": "single", "question": "What do Systems do?", "options": ["Store data", "Operate on entities with specific components", "Handle graphics only", "Manage files"], "correctAnswer": "Operate on entities with specific components", "explanation": "Systems implement logic by processing entities that have required components.", "points": 10}, {"id": "q4", "type": "multiple", "question": "ECS benefits?", "options": ["Composition over inheritance", "Reusable systems", "Spaghetti code", "Data-oriented design"], "correctAnswer": ["Composition over inheritance", "Reusable systems", "Data-oriented design"], "explanation": "ECS promotes clean architecture through composition, reusability, and data focus.", "points": 20}, {"id": "q5", "type": "short-answer", "question": "How does ECS improve code maintainability?", "correctAnswer": "ECS separates data from logic, enables composition over inheritance, makes systems reusable across entity types, and allows easy addition/removal of features without affecting other code", "explanation": "ECS creates clean separation and flexibility, making code easier to maintain and extend.", "points": 40}]},
  "environment": {"setupSteps": ["Start fresh project or refactor existing one", "Use TypeScript for better component typing", "Consider using a library like bitECS for production"], "commands": ["# TypeScript helps with ECS\ninterface Component {}\nclass Entity {\n    components = new Map<new() => Component, Component>();\n}"], "troubleshooting": [{"issue": "ECS feels overcomplicated", "solution": "Start simple: just separate data (components) from logic (systems). Don't need perfect ECS for small games."}, {"issue": "Performance worse than before", "solution": "ECS shines with many entities. For small games, simple OOP might be fine. Consider caching component queries."}]}
}
